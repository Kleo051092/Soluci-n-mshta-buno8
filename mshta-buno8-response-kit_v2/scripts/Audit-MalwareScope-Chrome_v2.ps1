<#
.SYNOPSIS
  AUDIT (PHASE 1): Scope review of the mshta/buno8.ru/Wacatac/OfferCore incident.
  Collects evidence of persistence, Defender events, and browser data-at-risk (Chrome/Edge).
  READ-ONLY: does NOT clean or modify the system (only reads/copies evidence).

.NOTES
  - ASCII-only strings to avoid parser issues on ANSI editors.
  - Avoids using Export-ScheduledTask inside Where-Object (prevents 0x80070057 spam).
  - Outputs under: C:\ProgramData\MshtaCleanup\Audit-YYYYMMDD-HHMMSS\
#>

[CmdletBinding()]
param(
  [switch]$DeepChrome,         # If sqlite3.exe is present, run counts/tops queries (no secrets)
  [int]$Days = 30,             # Time window for Defender/EventLog
  [int]$MaxRows = 100          # Limit for per-query rows
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Continue'

function New-Dir([string]$p) { if (-not (Test-Path $p)) { New-Item -ItemType Directory -Path $p -Force | Out-Null } }
function Log { param([string]$Message)
  $line = "[{0}] {1}" -f (Get-Date -Format 'u'), $Message
  Write-Host $line
  Add-Content -Path $Global:LogFile -Value $line
}

# --- Prepare output ---
$Root = Join-Path $env:ProgramData "MshtaCleanup"
New-Dir $Root
$TS = Get-Date -Format 'yyyyMMdd-HHmmss'
$Out = Join-Path $Root ("Audit-{0}" -f $TS)
New-Dir $Out
$Global:LogFile = Join-Path $Out "audit.log"
Log "==== AUDIT START ===="
Log ("Params: DeepChrome={0} Days={1} MaxRows={2}" -f $DeepChrome, $Days, $MaxRows)

# --- 0) Network/Proxy/HOSTS snapshot ---
try {
  $netDir = Join-Path $Out "Network"; New-Dir $netDir
  ipconfig /all | Out-File -FilePath (Join-Path $netDir 'ipconfig_all.txt') -Encoding UTF8
  netsh winhttp show proxy | Out-File -FilePath (Join-Path $netDir 'winhttp_proxy.txt') -Encoding UTF8
  foreach ($k in @('HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings','HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings')) {
    try { reg query ($k -replace 'HKCU:\\','HKCU\') | Out-File -FilePath (Join-Path $netDir ((Split-Path $k -Leaf) + '.txt')) -Encoding UTF8 } catch {}
  }
  $hosts = Join-Path $env:SystemRoot "System32\drivers\etc\hosts"
  if (Test-Path $hosts) { Copy-Item -LiteralPath $hosts -Destination (Join-Path $netDir "hosts.snapshot") -Force }
  Log "Network/Proxy/HOSTS captured."
} catch { Log ("WARN Network snapshot: {0}" -f $_.Exception.Message) }

# --- 1) mshta.exe processes ---
try {
  $procs = Get-CimInstance Win32_Process -Filter "name='mshta.exe'" -ErrorAction SilentlyContinue
  $procs | Select ProcessId, CommandLine, CreationDate |
    Export-Csv -LiteralPath (Join-Path $Out 'mshta_processes.csv') -NoTypeInformation -Encoding UTF8
  if ($procs) { Log ("mshta.exe running: {0}" -f $procs.Count) } else { Log "mshta.exe not running." }
} catch { Log ("WARN mshta processes: {0}" -f $_.Exception.Message) }

# --- 2) Scheduled Tasks (NO Export in filter) ---
try {
  $regexTasks = 'mshta|\.hta\b|wscript\.exe|cscript\.exe|rundll32\.exe.*(javascript|_)\b|bitsadmin|powershell\.exe\s+-enc'
  $tasksDir = Join-Path $Out 'ScheduledTasks'; New-Dir $tasksDir
  $allTasks = Get-ScheduledTask -ErrorAction SilentlyContinue
  $susTasks = foreach ($t in $allTasks) {
    $hit = $false
    foreach ($a in @($t.Actions)) {
      $exec = $null; $args = $null
      try { $exec = $a.Execute } catch {}
      try { $args = $a.Arguments } catch {}
      if (("$exec $args") -match $regexTasks) { $hit = $true; break }
    }
    if ($hit) { $t }
  }
  $susTasks |
    Select TaskPath, TaskName, State,
           @{n='Actions';e={ (@($_.Actions) | % { ($_.Execute + ' ' + $_.Arguments).Trim() }) -join ' | ' }} |
    Export-Csv -LiteralPath (Join-Path $tasksDir 'suspicious_tasks.csv') -NoTypeInformation -Encoding UTF8

  foreach ($t in $susTasks) {
    $safe = (('{0}_{1}' -f ($t.TaskPath -replace '[\\/:"*?<>|]','_').Trim('_'), ($t.TaskName -replace '[\\/:"*?<>|]','_').Trim('_')))
    try {
      Export-ScheduledTask -TaskName $t.TaskName -TaskPath $t.TaskPath |
        Set-Content -LiteralPath (Join-Path $tasksDir "$safe.xml") -Encoding UTF8
    } catch {
      try { schtasks /query /tn "$($t.TaskPath)$($t.TaskName)" /fo LIST /v |
        Out-File -FilePath (Join-Path $tasksDir "$safe.txt") -Encoding UTF8 } catch {}
    }
  }
  Log ("Suspicious tasks: {0}" -f (@($susTasks).Count))
} catch { Log ("WARN tasks: {0}" -f $_.Exception.Message) }

# --- 3) Run/RunOnce keys ---
try {
  $runDir = Join-Path $Out 'RunKeys'; New-Dir $runDir
  $paths = @(
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\Run',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    'HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Run',
    'HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce'
  )
  $regexRun = 'mshta|buno8\.ru|\.hta\b|wscript\.exe|cscript\.exe|powershell\.exe'
  $rows = @()
  foreach ($p in $paths) {
    if (-not (Test-Path $p)) { continue }
    $props = Get-ItemProperty -Path $p -ErrorAction SilentlyContinue
    foreach ($pp in $props.PSObject.Properties) {
      if ($pp.MemberType -ne 'NoteProperty') { continue }
      $val = [string]$pp.Value
      if ($val -and ($val -match $regexRun)) {
        $rows += [pscustomobject]@{ Path=$p; Name=$pp.Name; Value=$val }
      }
    }
  }
  $rows | Export-Csv -LiteralPath (Join-Path $runDir 'run_suspicious.csv') -NoTypeInformation -Encoding UTF8
  Log ("Run/RunOnce hits: {0}" -f (@($rows).Count))
} catch { Log ("WARN Run/RunOnce: {0}" -f $_.Exception.Message) }

# --- 4) WMI Subscriptions ---
try {
  $wmiDir = Join-Path $Out 'WMI'; New-Dir $wmiDir
  $ns='root\subscription'
  $regexWmi = 'mshta|buno8\.ru|\.hta\b|wscript\.exe|cscript\.exe|powershell\.exe'
  $consCmd = Get-WmiObject -Namespace $ns -Class CommandLineEventConsumer -ErrorAction SilentlyContinue
  $consScr = Get-WmiObject -Namespace $ns -Class ActiveScriptEventConsumer -ErrorAction SilentlyContinue
  $filters = Get-WmiObject -Namespace $ns -Class __EventFilter -ErrorAction SilentlyContinue
  $binds  = Get-WmiObject -Namespace $ns -Class __FilterToConsumerBinding -ErrorAction SilentlyContinue

  $consCmd | Select Name, CommandLineTemplate | Export-Csv -LiteralPath (Join-Path $wmiDir 'CommandLineEventConsumer.csv') -NoTypeInformation -Encoding UTF8
  $consScr | Select Name, ScriptingEngine | Export-Csv -LiteralPath (Join-Path $wmiDir 'ActiveScriptEventConsumer.csv') -NoTypeInformation -Encoding UTF8
  $filters | Select Name, Query | Export-Csv -LiteralPath (Join-Path $wmiDir '__EventFilter.csv') -NoTypeInformation -Encoding UTF8
  $binds  | Select Filter, Consumer | Export-Csv -LiteralPath (Join-Path $wmiDir '__FilterToConsumerBinding.csv') -NoTypeInformation -Encoding UTF8

  $susWmi = @()
  $susWmi += $consCmd | ? { $_.CommandLineTemplate -match $regexWmi }
  $susWmi += $consScr | ? { $_.ScriptText -match $regexWmi }
  $susWmi += $filters | ? { $_.Query -match $regexWmi }
  $susWmi | Select * | Export-Csv -LiteralPath (Join-Path $wmiDir 'suspicious_wmi.csv') -NoTypeInformation -Encoding UTF8
  Log ("Suspicious WMI items: {0}" -f (@($susWmi).Count))
} catch { Log ("WARN WMI: {0}" -f $_.Exception.Message) }

# --- 5) Startup + INetCache + Prefetch ---
try {
  $startDir = Join-Path $Out 'Startup'; New-Dir $startDir
  $startupDirs = @("$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup", "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup")
  $regexStart = 'mshta|buno8\.ru|\.hta\b|wscript\.exe|cscript\.exe|powershell\.exe'
  $rowsS = @()
  foreach ($s in $startupDirs) {
    if (-not (Test-Path $s)) { continue }
    Get-ChildItem -Path $s -File -Include *.lnk,*.url,*.hta,*.js,*.vbs,*.cmd,*.bat,*.ps1 -ErrorAction SilentlyContinue | ForEach-Object {
      $detail = ""
      if ($_.Extension -ieq ".lnk") {
        try { $w = New-Object -ComObject WScript.Shell; $sc = $w.CreateShortcut($_.FullName); $detail = "$($sc.TargetPath) $($sc.Arguments)" } catch {}
      } else {
        try { $c = Get-Content -LiteralPath $_.FullName -Raw -ErrorAction SilentlyContinue; $detail = $c.Substring(0,[Math]::Min(200,$c.Length)) } catch {}
      }
      if ($detail -match $regexStart) {
        $rowsS += [pscustomobject]@{ File=$_.FullName; Detail=$detail }
      }
    }
  }
  $rowsS | Export-Csv -LiteralPath (Join-Path $startDir 'startup_suspicious.csv') -NoTypeInformation -Encoding UTF8

  $inetDir = Join-Path $Out 'INetCache'; New-Dir $inetDir
  $inet = "$env:LOCALAPPDATA\Microsoft\Windows\INetCache"
  if (Test-Path $inet) {
    Get-ChildItem $inet -Recurse -ErrorAction SilentlyContinue | ? { $_.FullName -match 'buno8\.ru|\.hta$' } |
      Select FullName, Length, LastWriteTime | Export-Csv -LiteralPath (Join-Path $inetDir 'inetcache_hits.csv') -NoTypeInformation -Encoding UTF8
  }

  $pfDir = Join-Path $Out 'Prefetch'; New-Dir $pfDir
  $pf = "$env:SystemRoot\Prefetch"
  if (Test-Path $pf) {
    Get-ChildItem -Path $pf -Filter "MSHTA*.pf" -ErrorAction SilentlyContinue |
      Select Name, Length, LastWriteTime |
      Export-Csv -LiteralPath (Join-Path $pfDir 'mshta_prefetch.csv') -NoTypeInformation -Encoding UTF8
  }
  Log "Startup/INetCache/Prefetch done."
} catch { Log ("WARN Startup/Cache/Prefetch: {0}" -f $_.Exception.Message) }

# --- 6) Defender: threats, detections, events ---
try {
  $defDir = Join-Path $Out 'Defender'; New-Dir $defDir
  try {
    Get-MpThreat | Export-Csv -LiteralPath (Join-Path $defDir 'Get-MpThreat.csv') -NoTypeInformation -Encoding UTF8
    Get-MpThreatDetection | Export-Csv -LiteralPath (Join-Path $defDir 'Get-MpThreatDetection.csv') -NoTypeInformation -Encoding UTF8
  } catch { Log "INFO: Get-MpThreat/Detection unavailable or empty." }
  try {
    $from = (Get-Date).AddDays(-[math]::Abs($Days))
    $ev = Get-WinEvent -LogName "Microsoft-Windows-Windows Defender/Operational" -ErrorAction SilentlyContinue |
      Where-Object { $_.TimeCreated -ge $from }
    $ev | Select TimeCreated, Id, ProviderName, LevelDisplayName, Message |
      Export-Csv -LiteralPath (Join-Path $defDir 'Defender_Operational_Events.csv') -NoTypeInformation -Encoding UTF8
  } catch { Log ("WARN Defender EventLog: {0}" -f $_.Exception.Message) }
  Log "Defender exported."
} catch { Log ("WARN Defender: {0}" -f $_.Exception.Message) }

# --- 7) Chrome/Edge remnants (install paths, tasks, services, policies) ---
try {
  $chrDir = Join-Path $Out 'Chrome'; New-Dir $chrDir
  $chromePaths = @(
    "$env:ProgramFiles\Google\Chrome",
    "$env:ProgramFiles(x86)\Google\Chrome",
    "$env:LOCALAPPDATA\Google\Chrome",
    "$env:LOCALAPPDATA\Google\Chrome\User Data"
  )
  $chromePaths | ForEach-Object { [pscustomobject]@{ Path=$_; Exists=(Test-Path $_) } } |
    Export-Csv -LiteralPath (Join-Path $chrDir 'paths_exists.csv') -NoTypeInformation -Encoding UTF8

  $pols = @('HKLM:\Software\Policies\Google\Chrome','HKCU:\Software\Policies\Google\Chrome','HKLM:\Software\Policies\Google','HKCU:\Software\Policies\Google')
  $polRows = @()
  foreach ($k in $pols) {
    if (Test-Path $k) {
      try {
        $props = Get-ItemProperty -Path $k
        foreach ($pp in $props.PSObject.Properties) {
          if ($pp.MemberType -eq 'NoteProperty') { $polRows += [pscustomobject]@{ HiveKey=$k; Name=$pp.Name; Value=$pp.Value } }
        }
      } catch {}
    }
  }
  $polRows | Export-Csv -LiteralPath (Join-Path $chrDir 'policies.csv') -NoTypeInformation -Encoding UTF8

  $gtasks = Get-ScheduledTask -ErrorAction SilentlyContinue | ? { $_.TaskName -match '^GoogleUpdate' -or $_.TaskPath -match '\\Google\\' }
  $gtasks | Select TaskPath, TaskName, State |
    Export-Csv -LiteralPath (Join-Path $chrDir 'google_tasks.csv') -NoTypeInformation -Encoding UTF8

  $gsvc = foreach ($svc in @('gupdate','gupdatem')) {
    $s = Get-Service -Name $svc -ErrorAction SilentlyContinue
    if ($s) { [pscustomobject]@{ Name=$s.Name; Status=$s.Status; StartType=$s.StartType } }
  }
  $gsvc | Export-Csv -LiteralPath (Join-Path $chrDir 'google_services.csv') -NoTypeInformation -Encoding UTF8
} catch { Log ("WARN Chrome remnants: {0}" -f $_.Exception.Message) }

# --- 8) Browser profiles (Chrome/Edge) and DB metadata; optional sqlite3 counts/tops ---
function Get-SqliteExe {
  $cands = @('sqlite3.exe',
             "$env:ProgramFiles\sqlite\sqlite3.exe",
             "$env:ProgramFiles(x86)\sqlite\sqlite3.exe",
             "$env:SystemRoot\System32\sqlite3.exe")
  foreach ($c in $cands) {
    $cmd = Get-Command $c -ErrorAction SilentlyContinue
    if ($cmd) { return $cmd.Source }
  }
  return $null
}

function SafeCopy([string]$src, [string]$dst) {
  try { Copy-Item -LiteralPath $src -Destination $dst -Force -ErrorAction Stop; return $true } catch { return $false }
}

try {
  $navDir = Join-Path $Out 'BrowserData'; New-Dir $navDir
  $profiles = @()
  $chromeUserData = "$env:LOCALAPPDATA\Google\Chrome\User Data"
  if (Test-Path $chromeUserData) {
    Get-ChildItem -Path $chromeUserData -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '^(Default|Profile \d+)$' } | ForEach-Object {
      $profiles += [pscustomobject]@{ Browser='Chrome'; Profile=$_.Name; Path=$_.FullName }
    }
  }
  $edgeUserData = "$env:LOCALAPPDATA\Microsoft\Edge\User Data"
  if (Test-Path $edgeUserData) {
    Get-ChildItem -Path $edgeUserData -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '^(Default|Profile \d+)$' } | ForEach-Object {
      $profiles += [pscustomobject]@{ Browser='Edge'; Profile=$_.Name; Path=$_.FullName }
    }
  }
  $profiles | Export-Csv -LiteralPath (Join-Path $navDir 'profiles.csv') -NoTypeInformation -Encoding UTF8

  $dbRows = @()
  $dbNames = @('Login Data','Cookies','Web Data','History','Network\Cookies','Network\Cookies-journal','Downloads','Top Sites')
  foreach ($p in $profiles) {
    foreach ($db in $dbNames) {
      $f = Join-Path $p.Path $db
      if (Test-Path $f) {
        $fi = Get-Item -LiteralPath $f
        $dbRows += [pscustomobject]@{ Browser=$p.Browser; Profile=$p.Profile; File=$db; FullPath=$fi.FullName; Size=$fi.Length; LastWriteTimeUtc=$fi.LastWriteTimeUtc }
        $destDir = Join-Path $navDir ($p.Browser + '_' + $p.Profile); New-Dir $destDir
        SafeCopy $fi.FullName (Join-Path $destDir (Split-Path $fi.FullName -Leaf)) | Out-Null
      }
    }
  }
  $dbRows | Export-Csv -LiteralPath (Join-Path $navDir 'db_metadata.csv') -NoTypeInformation -Encoding UTF8

  if ($DeepChrome) {
    $sqlite = Get-SqliteExe
    if ($sqlite) {
      Log ("sqlite3.exe found: {0}" -f $sqlite)
      $queries = @{
        'LoginData_count.csv'   = "select count(*) as logins_count from logins;"
        'Cookies_top.csv'       = "select host_key, count(*) as c from cookies group by host_key order by c desc limit {0};" -f $MaxRows
        'Autofill_top.csv'      = "select name, count(*) as c from autofill where name is not null group by name order by c desc limit {0};" -f $MaxRows
        'History_top.csv'       = "select url, visit_count from urls order by visit_count desc limit {0};" -f $MaxRows
        'Downloads_recent.csv'  = "select datetime(start_time/1000000-11644473600,'unixepoch') as start_utc, target_path from downloads order by start_time desc limit {0};" -f $MaxRows
      }
      foreach ($p in $profiles) {
        $destDir = Join-Path $navDir ($p.Browser + '_' + $p.Profile)
        foreach ($kv in $queries.GetEnumerator()) {
          $outCsv = Join-Path $destDir $($kv.Key)
          $dbFile = $null
          if ($kv.Key -like 'LoginData*')     { $dbFile = Join-Path $destDir 'Login Data' }
          elseif ($kv.Key -like 'Cookies*')   { $dbFile = Join-Path $destDir 'Cookies' }
          elseif ($kv.Key -like 'Autofill*')  { $dbFile = Join-Path $destDir 'Web Data' }
          elseif ($kv.Key -like 'History*')   { $dbFile = Join-Path $destDir 'History' }
          elseif ($kv.Key -like 'Downloads*') { $dbFile = Join-Path $destDir 'History' }
          if (-not (Test-Path $dbFile)) { continue }
          try { & $sqlite -header -csv $dbFile $kv.Value | Out-File -FilePath $outCsv -Encoding UTF8 }
          catch { Log ("WARN sqlite query failed ({0}/{1}): {2}" -f $p.Browser, $p.Profile, $_.Exception.Message) }
        }
      }
    } else {
      Log "sqlite3.exe not found; skipping Chrome/Edge content queries."
    }
  }
} catch { Log ("WARN BrowserData: {0}" -f $_.Exception.Message) }

# --- 9) Data-at-risk summary (no secrets) ---
try {
  $summary = @()
  $summary += "POSSIBLE EXFILTRATION (indicators only, not confirmation)"
  $summary += ("Time window for Defender/EventLog: last {0} days" -f $Days)
  $summary += ""

  $defDetCsv = Join-Path (Join-Path $Out 'Defender') 'Get-MpThreatDetection.csv'
  if (Test-Path $defDetCsv) {
    $det = Import-Csv -LiteralPath $defDetCsv
    $g = $det | Group-Object Threat | Sort-Object Count -Descending
    $summary += "Defender detections by Threat:"
    foreach ($x in $g) { $summary += ("  - {0}: {1}" -f $x.Name, $x.Count) }
  } else {
    $summary += "No Get-MpThreatDetection.csv (Defender not available or no data)."
  }
  $summary += ""

  $dbMetaCsv = Join-Path (Join-Path $Out 'BrowserData') 'db_metadata.csv'
  if (Test-Path $dbMetaCsv) {
    $rows = Import-Csv -LiteralPath $dbMetaCsv
    $summary += "Browser databases present (typical targets):"
    $byFile = $rows | Group-Object File | Sort-Object Count -Descending
    foreach ($b in $byFile) { $summary += ("  - {0}: {1} profile(s)" -f $b.Name, $b.Count) }
  } else {
    $summary += "No browser DB metadata found."
  }

  $navDir = Join-Path $Out 'BrowserData'
  $tops = Get-ChildItem -Path $navDir -Recurse -Filter *.csv -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '(Cookies_top|LoginData_count|Autofill_top|History_top|Downloads_recent)\.csv$' }
  if ($tops) {
    $summary += ""
    $summary += "CSV outputs generated (counts/tops, no secrets):"
    foreach ($c in $tops) { $summary += ("  - {0}" -f $c.FullName) }
  }

  $summaryPath = Join-Path $Out "Possible_Exfiltration_Summary.txt"
  $summary | Set-Content -LiteralPath $summaryPath -Encoding UTF8
  Log ("Summary written: {0}" -f $summaryPath)
} catch { Log ("WARN summary: {0}" -f $_.Exception.Message) }

Log "==== AUDIT END ===="
Write-Host ("Evidence and reports: {0}" -f $Out)
